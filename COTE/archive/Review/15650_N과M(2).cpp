// 백준 15650번 - N과 M (2)
// 난이도: 실버3
// 알고리즘: 백트래킹 (조합 - Combination)

#include "utils/fileio.h"  // 제출 시 삭제

#include <iostream>
#include <vector>

using namespace std;

// N: 1부터 N까지의 자연수 중에서 선택
// M: M개를 고르는 조합
int N, M;

// arr: 현재까지 선택한 숫자들을 저장하는 배열
// arr[0] = 첫 번째 선택, arr[1] = 두 번째 선택, ...
int arr[10] = {0};

// visited: 각 숫자가 이미 선택되었는지 체크
// visited[i] = true면 숫자 i가 현재 조합에 포함됨
bool visited[10] = {false};

// solve: 백트래킹 함수 (조합 생성)
// num: 현재 선택할 숫자
// depth: 현재 선택한 개수 (0부터 시작, M-1까지)
//
// 백트래킹의 3단계: 선택 → 탐색 → 복구
void solve(int num, int depth)
{
    // === 1단계: 선택 (Choose) ===
    // 현재 depth 위치에 num을 선택
    arr[depth] = num;
    visited[num] = true;

    // 예: N=4, M=2에서 첫 번째로 1을 선택했다면
    // arr[0] = 1, visited[1] = true, depth = 0

    // === 2단계: 종료 조건 체크 ===
    // M개를 모두 선택했으면 출력 후 종료
    if (depth + 1 == M)
    {
        // depth는 0부터 시작하므로 depth+1 == M이면 M개 선택 완료
        // 예: M=2일 때, depth=1이면 arr[0], arr[1] 두 개 선택됨
        for (int i = 0; i < M; i++)
            cout << arr[i] << " ";
        cout << '\n';

        // ⚠️ 중요: return 전에 복구를 하지 않는 이유
        // → 함수가 종료되면 자동으로 라인 35의 복구 코드로 돌아감
        return;
    }

    // === 3단계: 탐색 (Explore) ===
    // 조합의 핵심: "오름차순"으로만 선택!
    // num+1부터 시작하여 num보다 큰 수만 선택 가능
    // 이렇게 하면 중복 조합 방지 (예: [1,2]와 [2,1]이 따로 나오지 않음)
    for (int i = num + 1; i <= N; i++)
    {
        // 이미 선택된 숫자는 스킵 (중복 방지)
        if (visited[i] == false)
        {
            // === 재귀 호출 (탐색) ===
            // i를 다음 선택으로 하고, depth를 1 증가시켜 재귀
            // 예: solve(1, 0) → solve(2, 1) 호출
            solve(i, depth + 1);

            // === 4단계: 복구 (Unchoose) - 재귀 직후! ===
            // ⚠️ 백트래킹의 핵심!
            // solve(i, depth+1)에서 돌아온 후, 선택을 취소하여
            // 다음 i+1 선택을 위해 상태를 초기화
            visited[i] = false;

            // 시각화 예시 (N=4, M=2):
            // [1, 2] 출력 → visited[2]=false로 복구
            // → 다음 루프에서 i=3 시도 가능
            // [1, 3] 출력 → visited[3]=false로 복구
            // → 다음 루프에서 i=4 시도 가능
            // [1, 4] 출력 → ...
        }
    }

    // === 5단계: 현재 선택 복구 ===
    // for문이 끝나면 현재 depth에서 선택한 num도 복구
    // 예: solve(1, 0)의 모든 탐색이 끝나면 visited[1] = false
    // → main의 다음 루프에서 i=2로 시작 가능
    visited[num] = false;

    // 전체 흐름 예시 (N=4, M=2):
    // main: solve(1, 0) 호출
    //   solve(1, 0): arr[0]=1, visited[1]=true
    //     solve(2, 1): arr[1]=2 → 출력 [1, 2] → return
    //     visited[2]=false (복구)
    //     solve(3, 1): arr[1]=3 → 출력 [1, 3] → return
    //     visited[3]=false (복구)
    //     solve(4, 1): arr[1]=4 → 출력 [1, 4] → return
    //     visited[4]=false (복구)
    //   visited[1]=false (복구)
    // main: solve(2, 0) 호출
    //   solve(2, 0): arr[0]=2, visited[2]=true
    //     solve(3, 1): arr[1]=3 → 출력 [2, 3] → return
    //     ...
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> N >> M;

    // 1부터 N까지 각 숫자를 시작점으로 조합 생성
    // i=1: [1, ...], [1, ...], ... 로 시작하는 모든 조합
    // i=2: [2, ...], [2, ...], ... 로 시작하는 모든 조합
    // ...
    // i=N: [N, ...] 로 시작하는 조합 (N-M+1까지만 의미 있음)
    for (int i = 1; i <= N; i++)
    {
        solve(i, 0);  // i를 첫 번째 원소로 하는 조합들을 모두 생성
    }

    return 0;
}

// ============================================================
// 조합(Combination) vs 순열(Permutation) 차이
// ============================================================
//
// N과 M (1) - 순열:
//   - 순서가 다르면 다른 것: [1,2] ≠ [2,1]
//   - for (int i = 1; i <= N; i++)  // 1부터 N까지 모두 시도
//
// N과 M (2) - 조합:
//   - 순서가 달라도 같은 것: [1,2] = [2,1] (하나만 출력)
//   - for (int i = num+1; i <= N; i++)  // num보다 큰 수만 시도
//   - 이렇게 하면 자동으로 오름차순 보장!
//
// ============================================================
// ❓ 자주 묻는 질문: visited[num] = false 복구가 왜 필요한가?
// ============================================================
//
// Q: main에서 i=1 탐색 후 i=2로 넘어가면, 2로 시작하는 조합에
//    1은 절대 안 들어가는데 visited[1]=false로 복구가 필요한가?
//
// A: 맞습니다! 이 문제에서는 실제로 필요 없을 수도 있습니다!
//
// 이유:
// - solve(2, 0)에서는 for (int i = 2+1; ...)로 3부터 시작
// - 1은 다시 확인하지 않으므로 visited[1]이 true여도 무관
//
// 그럼 왜 복구를 하는가?
// 1️⃣ 백트래킹의 일반적인 패턴: "선택→탐색→복구" 습관화
// 2️⃣ 코드의 안전성: 나중에 코드를 수정할 때 버그 방지
// 3️⃣ 확장성: 문제가 조금만 바뀌어도 대응 가능
//
// 💡 사실 visited 배열 없이도 풀 수 있습니다!
//
// visited 배열 없는 버전:
// ------------------------------------------------------------
// void solve(int num, int depth) {
//     arr[depth] = num;
//
//     if (depth + 1 == M) {
//         for (int i = 0; i < M; i++)
//             cout << arr[i] << " ";
//         cout << '\n';
//         return;
//     }
//
//     // num+1부터 시작하므로 이미 선택한 숫자는 자동으로 제외됨!
//     for (int i = num + 1; i <= N; i++) {
//         solve(i, depth + 1);  // visited 체크 불필요!
//     }
// }
// ------------------------------------------------------------
//
// 조합 문제의 핵심:
// - "num+1부터 시작" 자체가 중복 방지 역할을 함
// - visited는 추가 안전장치일 뿐
//
// 하지만 백트래킹 학습 목적으로는 visited를 사용하는 것이 좋습니다!
//
// ============================================================
// 시간 복잡도: O(C(N, M) * M) = O(조합의 개수 * 각 조합 출력 시간)
// 공간 복잡도: O(M) (재귀 깊이)
// ============================================================