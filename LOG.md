# 🎯 코딩테스트 문제 풀이 기록

## 📊 문제 풀이 현황

| 날짜 | 사이트 | 문제번호 | 문제명 | 난이도 | 알고리즘 |
|------|--------|----------|--------|--------|----------|
| 2025-11-14 | 백준 | 1434 | 책 정리 | 브론즈 2 | 그리디 |
| 2025-11-15 | 백준 | 1920 | 수 찾기 | 실버 4 | 이분탐색 |
| 2025-11-15 | 백준 | 2748 | 피보나치 수 2 | 브론즈 1 | DP |
| 2025-11-15 | 백준 | 1463 | 1로 만들기 | 실버 3 | DP |
| 2025-11-15 | 백준 | 15649 | N과 M (1) | 실버 3 | 백트래킹 |
| 2025-11-16 | 백준 | 2805 | 나무 자르기 | 실버 2 | 이분탐색 |
| 2025-11-16 | 백준 | 1654 | 랜선 자르기 | 실버 2 | 이분탐색 |
| 2025-11-17 | 백준 | 11053 | ❌ 가장 긴 증가하는 부분 수열 | 실버 2 | DP |
| 2025-11-18 | 백준 | 15650 | ❌ N과 M (2) | 실버 3 | 백트래킹 |
| 2025-11-18 | 백준 | 15651 | N과 M (3) | 실버 3 | 백트래킹 |

---

## 📝 메모
- **2025-11-14**
  - 오랜만에 코딩테스트 재시작. 브론즈 2도 어렵게 느껴짐. 감을 되찾아야 함.

- **2025-11-15**
  - 약점 보완 시작! 이분탐색 문제(1920) 도전. 시간 초과 발생 → 입출력 최적화 + 이분탐색 로직 수정으로 해결.
  - DP 기초(2748) 학습. 순수 재귀(시간 초과) → Bottom-up DP(통과). DP 두 가지 방식(Tabulation vs Memoization) 개념 정리 완료. 약점 보완 중! (DP 10개 → 11개)
  - DP 심화(1463) 도전! 처음엔 Top-down 재귀로 풀었으나 비효율적. 코드 리뷰 후 Bottom-up 방식으로 완전히 다시 작성. DP의 역방향 사고(i/2에서 i로 가는 관점) 개념 확실히 이해! (DP 11개 → 12개)
  - 백트래킹 첫 도전(15649)! 처음엔 어려웠지만 힌트로 개념 이해 → 선택-탐색-복구 패턴 완벽 구현. 포인터 파라미터 활용, return 추가 등 코드 최적화까지 완료. 새 알고리즘 습득! (백트래킹 2개 → 3개)

- **2025-11-16**
  - 이분탐색 심화(2805) 도전! 매개변수 탐색(Parametric Search) 개념 학습. 처음에 무한루프(시간 초과) 발생 → 이분탐색 범위 조정 버그(`mid` 대신 `mid±1`) 수정. "정확한 값" 대신 "조건을 만족하는 최댓값/최솟값 찾기" 패턴 완벽 이해! 자세한 주석으로 논리 정리 완료. (이분탐색 4개 → 5개)
  - 이분탐색 연습(1654) 완료! 처음에 틀림 → 두 가지 중요한 실수 발견: ① `left = 0` 시작으로 인한 **Zero Division Error** (mid가 0이 될 수 있음) ② `int` 타입 사용으로 인한 **Integer Overflow** (랜선 길이 최대 2^31-1). `left = 1`로 수정 + 모든 변수를 `long long`으로 변경하여 해결. 이분탐색 문제의 **엣지 케이스**와 **타입 범위** 중요성 체감! (이분탐색 5개 → 6개)

- **2025-11-17**
  - ❌ **LIS 문제(11053) 틀림** - **Review 폴더에 추가하여 재도전 예정!**
    - **첫 번째 시도 실패**: `priority_queue` 사용 → LIS는 원래 배열의 순서를 유지해야 하는데, 정렬되어 순서 정보 손실. 반례: `[3, 1, 2]` → 출력 1 (정답: 2)
    - **두 번째 시도 실패**: DP 접근은 맞았으나 **엣지 케이스 처리 실수**. `maxDP`를 0으로 초기화하고 `if (A[j] < A[i])` 안에서만 갱신 → N=1이거나 감소 수열일 때 0 출력
    - **핵심 교훈**:
      - ① LIS는 "부분 수열"이므로 순서 유지가 필수 → priority_queue 같은 정렬 자료구조는 부적합
      - ② DP 문제에서는 **모든 dp[i] 값을 확인**해야 함. 증가 조건을 만족하지 않아도 `dp[i]=1`은 유효한 답!
      - ③ 엣지 케이스(N=1, 단조 감소 수열 등) 항상 고려하기
    - 올바른 DP 접근: `dp[i]` = i번째 원소를 마지막으로 하는 LIS 길이. 이중 for문으로 `A[j] < A[i]`일 때 `dp[i] = max(dp[i], dp[j]+1)`. 답은 `*max_element(dp.begin(), dp.end())`
    - **다음 복습 시 학습 목표**: O(N log N) 최적화 (이분탐색 활용), LIS 경로 복원

- **2025-11-18**
  - ❌ **조합 문제(15650) 틀림 (힌트 다수 필요)** - **Review 폴더에 추가!**
    - **문제점**: 백트래킹 기본 패턴과 조합 구현 이해 부족
    - **주요 실수**:
      - ① **main 함수 로직 오류**: `for (int i = 1; i <= N-M; i++)` → N까지가 아닌 N-M까지만 루프. 모든 시작점을 고려하지 못함
      - ② **중복 호출**: main에서 `solve(1, 0)`을 루프 밖에서 한 번 더 호출
      - ③ **visited 복구 위치 실수**: for문 안에서 `visited[i] = false`를 재귀 호출과 무관하게 모든 i에 대해 실행
      - ④ **백트래킹 패턴 미숙**: "재귀 직후" 복구해야 하는데, 잘못된 위치에 복구 코드 배치
    - **부족한 점**:
      - ① 백트래킹의 핵심 패턴 **"선택→탐색→복구"**의 순서를 정확히 이해하지 못함
      - ② 조합의 핵심 (`num+1`부터 시작)은 알았지만, 이것이 왜 중복을 방지하는지 완전히 이해 못함
      - ③ 재귀 함수의 흐름(호출 스택)을 머릿속으로 시뮬레이션하는 능력 부족
    - **긍정적인 점**:
      - ✅ 힌트를 받은 후 "visited[num] = false가 왜 필요한가?"라는 **날카로운 질문** 제기
      - ✅ 조합 문제에서 visited가 실제로 불필요할 수 있다는 것을 스스로 파악
      - ✅ 문제 해결 후 깊이 이해하려는 태도 (단순히 맞추고 넘어가지 않음)
    - **핵심 교훈**:
      - ① 백트래킹은 **"재귀 호출 바로 다음"**에 복구해야 함!
        ```cpp
        solve(i, depth + 1);  // 탐색
        visited[i] = false;    // 복구 (바로 다음!)
        ```
      - ② 조합의 핵심: `for (int i = num+1; ...)` 자체가 중복 방지. visited는 추가 안전장치일 뿐
      - ③ 재귀 함수는 종이에 호출 트리를 그려가며 흐름을 따라가는 연습 필요
    - **학습 전략**:
      - ✅ 백트래킹 기본 문제 더 풀기 (N과 M 시리즈 계속)
      - ✅ 재귀 호출 흐름을 **디버그 출력**으로 확인하는 습관화
      - ✅ "선택→탐색→복구" 패턴을 손으로 쓰면서 외우기
    - **다음 복습 시**: visited 없는 간단한 버전으로 다시 구현, N과 M (3), (4) 도전
  - ✅ **중복 순열 문제(15651) 성공!** - **visited의 필요성 정확히 판단**
    - **긍정적인 점**:
      - ① 코드 작성 단계에서 **"visited가 필요 없을 것 같다"**는 정확한 직감!
      - ② 중복 순열의 특성(같은 수 여러 번 선택 가능)을 올바르게 이해
      - ③ 불필요한 코드(visited 관련)를 과감히 제거하는 판단력
    - **핵심 개념 학습**:
      - ① **중복 순열** = visited 불필요 (모든 i를 매번 탐색)
      - ② **일반 순열** (15649) = visited 필요 (같은 수 중복 방지)
      - ③ **조합** (15650) = visited 필요 OR 시작 인덱스 제어 (`num+1`부터)
      - ④ 백트래킹 문제마다 visited의 필요성이 다름을 체감!
    - **성장 포인트**:
      - 이전 문제(15650)에서 어려움을 겪었지만, 바로 다음 문제에서 핵심 개념을 정확히 적용
      - "왜 필요한가?"를 먼저 생각하는 습관 형성 중
      - 단순 암기가 아닌 **개념 이해 기반 코딩** 실천
    - **백트래킹 진척**: 3개 → 4개

---

## 📌 참고 문서

- **실력 분석**: [SKILL.md](./SKILL.md) - 알고리즘별 강/약점 분석
- **학습 노트**: [NOTES.md](./NOTES.md) - 배운 개념 및 팁 정리
- **문제 추천**: [FOR_LLM.md](./FOR_LLM.md) - AI 기반 맞춤형 문제 추천 가이드
- **프로젝트 구조**: [README.md](./README.md) - 전체 프로젝트 소개
